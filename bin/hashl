#!/usr/bin/env perl
## Copyright Â© 2010 by Daniel Friesel <derf@finalrewind.org>
## License: WTFPL <http://sam.zoy.org/wtfpl>
##   0. You just DO WHAT THE FUCK YOU WANT TO.
use strict;
use warnings;
use 5.010;
use autodie;

use Cwd;
use Digest::SHA qw(sha1_hex);
use File::Find;
use Getopt::Long;
use IO::Handle;
use Storable qw(nstore retrieve);
use Time::Progress;

my $base = getcwd();
my $rel_paths = 1;
my $read_size = (2 ** 20) * 4; # 4 MiB
my $db_file = '.hashl.db';
my $total = 0;
my $cur = 0;
my $timer;

my $VERSION = '0.1';

my $db;

GetOptions(
	'd|database=s'  => \$db_file,
	's|read-size=i' => sub { $read_size = $_[1] * 1024 },
) or usage();

if (substr($db_file, 0, 1) ne '/') {
	$db_file = "${base}/${db_file}";
}

my $action = $ARGV[0];

sub usage {
	die(<<"EOF");
Usage: $0 [options] <update|list|info|...> [args]
See 'perldoc -F $0' (or 'man $0' if it is properly installed)
EOF

}

if (not defined $action) {
	usage();
}

if (-r $db_file) {
	$db = retrieve($db_file);
	$read_size = $db->{'config'}->{'read_size'};
}
else {
	$db->{'config'} = {
		read_size => $read_size,
	}
}

sub get_total {
	my $file = $File::Find::name;
	if (-f $file and not -l $file and $file ne $db_file) {
		$total++;
	}
}

sub drop_deleted {
	for my $file (keys %{$db->{'files'}}) {
		if (! -e $file) {
			delete $db->{'files'}->{$file};
		}
	}
}

sub hash_file {
	my ($file) = @_;
	my ($fh, $data);

	open($fh, '<', $file);
	binmode($fh);
	read($fh, $data, $read_size);
	close($fh);

	return sha1_hex($data);
}

sub hash_in_db {
	my ($hash) = @_;

	for my $name (keys %{$db->{'files'}}) {
		my $file = $db->{'files'}->{$name};

		if ($file->{'hash'} eq $hash) {
			return $name;
		}
	}
	return undef;
}

sub file_in_db {
	my ($file) = @_;

	return hash_in_db(hash_file($file));
}

sub db_find {
	if ($ARGV[1]) {
		given ($action) {
			when ('know-file') { exit (not defined file_in_db($ARGV[1])) }
			when ('know-hash') { exit (not defined hash_in_db($ARGV[1])) }
			when ('new-file') { exit (defined file_in_db($ARGV[1])) }
			when ('new-hash') { exit (defined hash_in_db($ARGV[1])) }
		}
	}
	else {
		while (my $line = <STDIN>) {
			chomp $line;
			if (
					($action eq 'know-file' and     defined file_in_db($line)) or
					($action eq 'know-hash' and     defined hash_in_db($line)) or
					($action eq  'new-file' and not defined file_in_db($line)) or
					($action eq  'new-hash' and not defined hash_in_db($line))) {
				say $line;
			}
		}
	}
}

sub db_info {
	printf(
		"Read size: %d bytes (%.f KiB)\n",
		$db->{'config'}->{'read_size'},
		$db->{'config'}->{'read_size'} / 1024,
	);
}

sub file_info {
	my ($file) = @_;

	printf(
		"File: %s\nSize: %d bytes\nHash: %s\n",
		$file,
		$db->{'files'}->{$file}->{'size'},
		$db->{'files'}->{$file}->{'hash'},
	);
}

sub process_file {
	my $file = $File::Find::name;
	my $path = $file;
	my ($size, $mtime) = (stat($file))[7,9];

	if (not -f $file or -l $file or $file eq $db_file) {
		return;
	}

	$cur++;

	if ($rel_paths) {
		$file = substr($file, length($base) + 1);
	}

	print $timer->report("\r\e[2KUpdating: %p done, %L elapsed, %E remaining", $cur);

	if (exists($db->{'files'}->{$file}) and
			$db->{'files'}->{$file}->{'mtime'} == $mtime and
			$db->{'files'}->{$file}->{'size'} == $size ) {
		return;
	}

	$db->{'files'}->{$file} = {
		hash => hash_file($path),
		mtime => $mtime,
		size => $size,
	};

	if (($cur % 100) == 0) {
		nstore($db, $db_file);
	}
}

if ($action eq 'update') {

	STDOUT->autoflush(1);

	drop_deleted();
	find(\&get_total, $base);

	$timer = Time::Progress->new();
	$timer->attr(
		min => 1,
		max => $total
	);

	find(\&process_file, $base);
	print "\n";
	nstore($db, $db_file);
}
elsif ($action eq 'list') {
	for my $name (sort keys %{$db->{'files'}}) {
		my $file = $db->{'files'}->{$name};
		printf("%s %s\n", $file->{'hash'}, $name);
	}
}
elsif ($action ~~ [qw[know-file know-hash new-file new-hash]]) {
	db_find();
}
elsif ($action eq 'info') {
	if ($ARGV[1]) {
		file_info($ARGV[1]);
	}
	else {
		db_info();
	}
}
else {
	usage();
}

__END__

=head1 NAME

B<hashl> - Create database with partial file hashes, check if other files are in it

=head1 SYNOPSIS

B<hashl> [B<-d> I<dbfile>] [B<-s> I<read-size>] I<action> [I<args>]

=head1 DESCRIPTION

Actions:

=over

=item B<info> [I<file>]

Show information on I<file> (or the database, if I<file> is not specified).

=item B<know-file> [I<file>]

When I<file> is specified: Returns true if I<file> (judged by its hash) is
already in the database, false otherwise.

When used without further arguments: Reads filenames from stdin (one per line)
and writes those to stdout which are already in the database.

=item B<know-hash> [I<hash>]

Like B<know-file>, but works with file hashes instead.

=item B<list>

List all files and their hashes.

=item B<new-file> [I<file>]

When I<file> is specified: Returns true if I<file> (judged by its hash) is not
in the database, false otherwise.

When used without further arguments: Reads filenames from stdin (one per line)
and writes those to stdout which are not in the database.

=item B<new-hash> [I<hash>]

Like B<new-file>, but works with file hashes instead.

=item B<update>

Update or create hash database.  Iterates over all files below the current
directory.

=back

=head1 OPTIONS

=over

=item B<-d>|B<--database> I<dbfile>

Use I<dbfile> instead of F<.hashl.db>

=item B<-s>|B<--read-size> I<bytes>

Change size of the part of each file which is hashed.  By default, B<hashl>
hashes the first 4 MiB.  Note that this option only makes sense for C<< hashl
update >> to create a new database.

=back

=head1 CONFIGURATION

None, so far

=head1 DEPENDENCIES

=over

=item * autodie (included with perl E<gt>= 5.10.1)

=item * Digest::SHA

=item * Time::Progress

=back

=head1 BUGS AND LIMITATIONS

Unknown.  This is alpha software.

=head1 EXAMPLES

=head2 LEECHING

First, create a database of your local files:

C<< cd /media/videos; hashl update >>

Now, assume you have a (possibly slow) external share mounted at
F</tmp/mnt/ext>.  You do not want to copy all files to your disk and then use
B<fdupes> or similar to weed out the duplicates.  Since you just used B<hashl>
to create a database with the hashes of the first 4MB of all your files, you
can now use it to check if you (very probably) already have any remote file.
For that, you only need to leech the first 4MB of every file on the share, and
not the whole file.  For example:

C<< for f (/tmp/mnt/ext/**/*(.)); hashl new-file $f && cp -v --parents $f
/media/videos/incoming/ || echo skip $f >>

=head2 EXTERNAL HARD DISK

Personally, I have all my videos on an external hard disk, which I usually do
not carry with me.  So, when I get new videos, I put them into F<~/lib/videos>
on my netboo, and then later copy them to the external disk.  Of course, it
can always happen that I get a movie I already have, or forget to move
something from F<~/lib/videos> to the external disk, especially since I also
always have some stuff from the disk in F<~/lib/videos>.

However, I can use B<hashl> to conveniently solve this issue.  Run
periodically:

C<< cd /media/argon; hashl -d ~/lib/video/.argon update >>

Now, I always have a list of files on the external disk with me.  When I get a
new file:

C<< hashl -d ~/lib/video/.argon new-file $file >>

And to find out which files are not on the external disk:

C<< cd ~/lib/video; print -l **/*(.) | hashl -d .argon new-file >>

=head1 AUTHOR

Copyright (C) 2010 by Daniel Friesel E<lt>derf@finalrewind.orgE<gt>

=head1 LICENSE

  0. You just DO WHAT THE FUCK YOU WANT TO.
